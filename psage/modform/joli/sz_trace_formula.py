# This file was *autogenerated* from the file sz_trace_formula.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4)
r"""
Traces of Hecke operators on the space of newforms on $\Gamma_0(m)$.

DESCRIPTION
    This is an implementation of the trace formulas $s_{k,m}(l,n)$
    as given in the article [S-Z].

REFERENCES
    [S-Z] N-P. Skoruppa and D. Zagier,
          Jacobi forms and a certain space of modular forms,
          Inv. Math. 94 (1988), 113--146

AUTHORS
    -- Nils-Peter Skoruppa (2007-08-15)

TODO
    Check alpha, p, gcd(l,m)>1

\section{Tutorial}

    xyz

"""

#*****************************************************************************
#       Copyright (C) 2007 Nils-Peter Skoruppa <skoruppa@math.uni-siegen.de>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#*****************************************************************************

__version__ = '$Id$'


from sage.rings.all import Integer
from sage.rings.arith import (factor, divisors, is_square, is_squarefree,
                              kronecker_symbol, gcd, moebius, sigma)
from sage.misc.functional import is_odd
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.rings.rational_field import RationalField
from sage.rings.rational import Rational
from sage.interfaces.gp import gp


def gegenbauer_pol( h, s):
    r"""
    OUTPUT
        The coefficient of $x^{2*h}$ in the Taylor expansion
        of  $1/(1 - \sqrt{s} x + x^2)$  around  $0$.

    INPUT
        h -- a positive integer
        s -- element of a ring
    """
    h = Integer( h)
    if h < _sage_const_0 :
        raise ValueError, "first argument %s must be a nonnegative integer" % h
    if _sage_const_0  == h:
        return s**_sage_const_0
    if _sage_const_1  == h:
        return s-s**_sage_const_0
    i = _sage_const_2 ; a = s-s**_sage_const_0 ; b = s**_sage_const_0
    while i <= h:
        c = b; b = a; a = (s-_sage_const_2 )*b - c; i += _sage_const_1
    return a


def ab( m):
    r"""
    OUTPUT
        The pair of positive integers $a,b$ such that $m=a^2b$
        with squarefree $b$.

    INPUT
        m -- a positive integer
    """
    m = Integer(m)
    if m <= _sage_const_0 :
        raise ValueError, "%s: must be a positive integer" % m
    f = factor(m)
    a=b=_sage_const_1
    for i in range(len(f)):
        a *= f[i][_sage_const_0 ]**(f[i][_sage_const_1 ]//_sage_const_2 )
        if is_odd( f[i][_sage_const_1 ]):
            b *= f[i][_sage_const_0 ]
    return (a,b)


def hurwitz_kronecker_class_no_x( n, D):
    r"""
    OUTPUT
        The generalized Hurwitz-Kronecker class number $H_n(D)$
        as defined in [S-Z].

    INPUT
        n -- an integer $\ge 1$
        D -- an integer $\le 0$
    """
    n = Integer(n)
    D = Integer(D)
    if n <= _sage_const_0 :
        raise ValueError, "%s: must be an integer >=1" % n
    if D > _sage_const_0 :
        raise ValueError, "%s: must be an integer <= 0" % D
    g =gcd( n, D)
    b = ab(g)[_sage_const_1 ]
    Dp = D/g/b
    if _sage_const_0  != (D/g)%b:
        return _sage_const_0
    return Rational( g*kronecker_symbol( Dp, n/g)*gp.qfbhclassno(-Dp))


def alpha( n):
    r"""
    OUTPUT
        Value at $n$ of the multiplicative arithmetic function
        which takes values $-1$ for $p$, $p^2$ and $+1$ for $p^3$,
        and $0$ otherwise, where $p$ is a prime, cf. [S-Z].

    INPUT
        n -- an integer $\ge 1$
    """
    return sum( moebius(n/d/d)*moebius(d) for d in divisors(ab(n)[_sage_const_0 ]))


def sz_s( k, m, l, n):
    r"""
    OUTPUT
        The function  $s_{k,m}(l,n)$, i.e.~the trace
        of $T(l) \circ W_n$ on the "certain" space
        $\mathcal{M}_{2k-2}^{\text{cusp}}(m)$ of modular forms
        as defined in [S-Z].

    INPUT
        l -- index of the Hecke operator, rel. prime to the level $m$
        n -- index of the Atkin-Lehner involution (exact divisor of $m$)
        k -- integer ($2k-2$ is the weight)
        m -- level
    """
    if k < _sage_const_2 :
        return _sage_const_0
    if _sage_const_1  != gcd(m,l):
        raise ValueError, \
              "gcd(%s,%s) != 1: not yet implemented" % (m,l)
    x = PolynomialRing( RationalField(), 'x').gen()
    p = gegenbauer_pol( k-_sage_const_2 , x)
    ellT = _sage_const_0
    for np in divisors(n):
        ellT -= sum( l**(k-_sage_const_2 ) \
                     * p( s*s*np/l) \
                     * hurwitz_kronecker_class_no_x( m/n, s*s*np*np - _sage_const_4 *l*np) \
                     for s in range( -(Integer(_sage_const_4 *l*np).isqrt()//np), \
                                     _sage_const_1 +(Integer(_sage_const_4 *l*np).isqrt()//np)) \
                     if is_squarefree(gcd(s*s,n//np)))/_sage_const_2

    parT = -sum( min( lp, l/lp)**(_sage_const_2 *k-_sage_const_3 ) \
                 * gcd( ab(n)[_sage_const_0 ], lp+l/lp) \
                 * gcd( ab(m/n)[_sage_const_0 ], lp-l/lp) \
                 for lp in divisors(l))/_sage_const_2

    if _sage_const_2  == k and is_square(m/n):
        corT = sigma(n,_sage_const_0 )*sigma(l,_sage_const_1 )
    else:
        corT = _sage_const_0

    return Integer( ellT + parT + corT)


def check( l, n, k, m):
    m = Integer(m)
    if m <= _sage_const_0 :
        raise ValueError, "%s: m must be a positive integer" % str(m)
    l = Integer(l)
    if l < _sage_const_1  or _sage_const_1  != gcd( l, m):
        raise ValueError, "%s: l must be a positive integer prime to %d" \
              % ( str(l), m)
    n = Integer(n)
    if n <=_sage_const_0  or _sage_const_0  != m%n or _sage_const_1  != gcd( n, m//n):
        raise ValueError, "%s: n must be an exact divisor of %d" \
              (str(n), m)
    k = Integer(k)

    m = Integer(m)
    return l, n, k, m


####################################################################
# Exported Functions
####################################################################


def trace_cusp_forms( l, n, k, m):
    r"""
    OUTPUT
        The trace of  $T(l) \circ W_n$  on $S_k(Gamma_0(m)$).

    INPUT
        l -- Hecke operator index (rel. prime to the level $m$)
        n -- Atkin-Lehner involution index (exact divisor of the level $m$)
        k -- weight
        m -- a level ($\ge 1$)
    """
    l, n, k, m = check( l, n, k, m)
    if is_odd(k) or k <= _sage_const_0 :
        return _sage_const_0
    return sum( sz_s( k//_sage_const_2 +_sage_const_1 , mp, l, gcd( n, mp)) \
                for mp in divisors(m) if is_squarefree(n/mp))


def trace_new_cusp_forms( l, n, k, m):
    r"""
    OUTPUT
        Rhe trace of  $T(l) \circ W_n$  on $S_k^{\text{new}}(Gamma_0(m)$).

    INPUT
        l -- Hecke operator index (rel. prime to the level $m$)
        n -- Atkin-Lehner involution index (exact divisor of the level $m$)
        k -- weight
        m -- a level ($\ge 1$)
    """
    l, n, k, m = check( l, n, k, m)
    if is_odd(k) or k <= _sage_const_0 :
        return _sage_const_0
    return sum( alpha( m//mp) * sz_s( k//_sage_const_2 +_sage_const_1 , mp, l, gcd( n, mp)) \
                for mp in divisors(m))


def trace_eisenstein_series( l, n, k, m):
    r"""
    OUTPUT
        The trace of  $T(l) \circ W_n$  on $M_k^{\text{Eis.}}(Gamma_0(m)$).

    INPUT
        l -- Hecke operator index (rel. prime to the level $m$)
        n -- Atkin-Lehner involution index (exact divisor of the level $m$)
        k -- weight
        m -- a level ($\ge 1$)
    """
    l, n, k, m = check( l, n, k, m)
    if is_odd(k) or k < _sage_const_0 :
        return _sage_const_0
    if _sage_const_0  == k and _sage_const_1  != n:
        return _sage_const_0
    if _sage_const_0  == k and _sage_const_1  == n:
        return sigma(l,_sage_const_0 )
    raise NotImplementedError, "requested traces not yet implemented"


def trace_new_eisenstein_series( l, n, k, m):
    r"""
    OUTPUT
        The trace of  $T(l) \circ W_n$  on $M_k^{\text{Eis., new}}(Gamma_0(m)$).

    INPUT
        l -- Hecke operator index (rel. prime to the level $m$)
        n -- Atkin-Lehner involution index (exact divisor of the level $m$)
        k -- weight
        m -- a level ($\ge 1$)
    """
    l, n, k, m = check( l, n, k, m)
    if is_odd(k) or k < _sage_const_0 :
        return _sage_const_0
    if _sage_const_0  == k:
        if _sage_const_1  == n == m:
            return sigma(l,_sage_const_0 )
        return _sage_const_0
    if False == is_square(m) or (_sage_const_2  == k and _sage_const_1  == m):
        return _sage_const_0
    raise NotImplementedError, "requested traces not yet implemented"


def trace_modular_forms( l, n, k, m):
    r"""
    OUTPUT
        The trace of  $T(l) \circ W_n$  on $M_k(Gamma_0(m)$).

    INPUT
        l -- Hecke operator index (rel. prime to the level $m$)
        n -- Atkin-Lehner involution index (exact divisor of the level $m$)
        k -- weight
        m -- a level ($\ge 1$)
    """
    l, n, k, m = check( l, n, k, m)
    return trace_eisenstein_series( l, n, k, m) \
           + trace_cusp_forms( l, n, k, m)


def trace_new_modular_forms( l, n, k, m):
    r"""
    OUTPUT
        The trace of  $T(l) \circ W_n$  on $M_k^{\text{new}}(Gamma_0(m)$).

    INPUT
        l -- Hecke operator index (rel. prime to the level $m$)
        n -- Atkin-Lehner involution index (exact divisor of the level $m$)
        k -- weight
        m -- a level ($\ge 1$)
    """
    l, n, k, m = check( l, n, k, m)
    return trace_new_eisenstein_series( l, n, k, m) \
           + trace_new_cusp_forms( l, n, k, m)
